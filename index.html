<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>JavaScript in 2015</title>

		<meta name="description" content="Despite JavaScript’s jaded past, it’s recent history highlights some real world usefulness. With the release of ES6 and a surge in platform, framework and library work, maybe it’s time to re-introduce yourself to the language and it’s community.">
		<meta name="author" content="Dave Nagoda">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<div class="slides">
				<section>
					<h1>JavaScript in 2015</h1>
					<h3>What's this language really like?</h3>
					<p>
						<small>Created by Dave Nagoda / <a href="mailto://dnagoda@clearwateranalytics.com">dnagoda@clearwateranalytics.com</a></small>
					</p>
					<aside class="notes">
						This presentation was created using <a href="http://lab.hakim.se/reveal-js/#/">reveal.js</a> and it's being served using <a href="http://gruntjs.com/">grunt</a> and <a href="https://nodejs.org/en/">nodejs</a>.
					</aside>
				</section>

				<section>
					<h2>Let's Get Started</h2>
					<p>
						<ul>
							<li class="fragment">We're pressed for time so...</li>
							<li class="fragment">JavaScript Language Highlights</li>
							<li class="fragment">How To Live In The Future</li>
							<span class="fragment"><li>Awesome</span><span class="fragment"> JavaScript</span></li></span>
						</ul>
					</p>
					<aside class="notes">
						<p>
						JavaScript is a dynamic, untyped and interpreted programming lanaguage. It is prototype based with first class functions. Althrough it is commonly used in an object oriented style, JavaScript is a multi-paradigm language, supporting both imperative and functional styles.
						</p>
					</aside>
				</section>

				<section>
					<h2>Everything Is Object-like</h2>
					<pre><code data-trim class="javascript">
var thing = {};
thing.question = 'Am I Thing One or Thing Two?';

console.log(thing)
> Object {question: "Am I Thing One or Thing 2?"}

console.log(typeof thing)
> "object"

console.log(thing instanceof Object)
> true
					</code></pre>
					<pre class="fragment"><code data-trim class="javascript">
var number = 42;
console.log(number.toString())
> "42"
					</code></pre>
					<aside class="notes">
						<p>
						Number, String, Boolean, null and undefined are more special. Along with some others, like Errors.
						</p>
					</aside>
				</section>

				<section>
					<h2>Functions Are First Class</h2>
					<pre><code data-trim class="javascript">
function firstClass() {
  return "I'm first class!";
}

function callIt(func) {
  return func();
}

console.log(callIt(firstClass));
> "I'm first class!"
					</code></pre>
					<aside class="notes">
						<p>
						Yeah! Pass functions around just like regular Objects.
						</p>
					</aside>
				</section>

				<section>
					<h2>Lexical Scoping</h2>
					<pre><code data-trim class="javascript">
var deal = "real";

function lexicallySpeaking() {
  return deal + " value";
}

console.log(lexicallySpeaking())
> "real value"
					</code></pre>
					<aside class="notes">
						<p>
						Function blocks have access to the variables defined in the same scope or above.
						</p>
					</aside>
				</section>

				<section>
					<h2>Block Scoping (ES6)</h2>
					<pre><code data-trim class="javascript">
if (true) {
	var hoistMe = "How rude!";
	let notMe = "Safe inside my block.";
}

console.log(hoistMe)
> "How rude!"

console.log(notMe)
> Reference Error
					</code></pre>
					<aside class="notes">
						<p>
						Non-function blocks don't get there own scope in JavaScript. This includes conditional blocks. But, ES6 intrduced the let statement, that specifically
						defines a variable as local to the block.

						Functions defined in blocks are allows block scoped starting in ES6.

						P.S. The reference error would only be thrown in strict mode.
						</p>
					</aside>
				</section>

				<section>
					<h2>Closures (a.k.a Awesome Sauce!)</h2>
					<pre><code data-trim class="javascript">
var fooVar = "This is not the string I you are looking for.";

function foo() {
	var fooVar = "Hidden this string is.";

	function bar() {
		return fooVar;
	}

	return bar;
}

console.log(fooVar)
> "This is not the string I you are looking for."
console.log(foo()())
> "Hidden this string is."
					</code></pre>
					<aside class="notes">
						<p>
						Which leads to closures. A closure is created whenever a nested function references a variable in it's lexical scope. Essentially, the original scoping is maintained
						regardless of where the function is ultimately called.
						</p>
					</aside>
				</section>

				<section>
					<h2>Spread Arguments (ES6)</h2>
					<pre><code data-trim class="javascript">
(function(...args) {
	console.log(args);
})(1, 2, 3);
> [1, 2, 3]
					</code></pre>
					<pre class="fragment"><code data-trim class="javascript">
(function(first, second, ...rest) {
  console.log(first);
  console.log(second);
  console.log(rest instanceof Array);
})(1, 2, 4, 5, 6);
> 1
> 2
> true
					</code></pre>
					<aside class="notes">
						The (function)() form is called an Immediately Invoked Function Expression IIFE.

						The spread '...' operator gathers all the arguments into an Array. This operator can also be used in non function definition contexts to break apart an array of elements.
					</aside>
				</section>

				<section>
					<h2>Default Arguments (ES6)</h2>
					<pre><code data-trim class="javascript">
(function(x, y = 10) {
	console.log("x is " + x);
  	console.log("y is " + y);
})();
> "x is undefined"
> "y is 10"
					</code></pre>
					<pre class="fragment"><code data-trim class="javascript">
var initialX = 1;
var initialY = function() { return initialX * 2; };

(function(x = initialX, y = initialY()) {
  	console.log("x is " + x);
  	console.log("y is " + y);
})();
> "x is 1"
> "y is 2"
					</code></pre>
					<aside class="notes">
						Default arguments. Null coerces to zero and undefined looks like it wasn't provided.
					</aside>
				</section>

				<section>
					<h2>Destructuring (ES6)</h2>
					<pre><code data-trim class="javascript">
var a, b, c;
function foo() {
	return [1, 2, 3];
}

[a, b, c] = foo();
console.log(c + ', ' + b + ', ' + a);
> 3, 2, 1
					</code></pre>
					<pre class="fragment"><code data-trim class="javascript">
function bar() {
  return {
    name: {
    	first: "Dave",
      	last: "Nagoda"
    }
  };
}

var {name: {first: firstName}} = bar();
console.log(firstName);
> Dave
					</code></pre>
					<aside class="notes">
						Destructuring allows you to assign complex function returns to matching structures of variables. This also works for objects! Destructuring is a deep subject and there are a lot of ways to use it.
					</aside>
				</section>

				<section>
					<h2>Arrow Functions (ES6)</h2>
					<pre><code data-trim class="javascript">
var foo = (x, y) => console.log(x + y);
foo(4, 5);
> 9
					</code></pre>
					<pre class="fragment"><code data-trim class="javascript">
var bar = (x, y = 0) => {
	var z = x + y;
	console.log(z);
};
bar(5);
> 5
					</code></pre>
					<aside class="notes">
						Arrow functions allow you to define simple functions quickly. They have some other
						advantages that help with binding as well. They are always anonymous!
					</aside>
				</section>

				<section>
					<h2>Functional Operators</h2>
					<pre><code data-trim class="javascript">
var angles = [0, 45, 90];
var degreesToRadians = (angle) => angle / 180 * Math.PI;
var radiansToUnitVector = (radians) => {
    return {x: Math.cos(radians), y: Math.sin(radians)};
};

var uvs = angles.map(degreesToRadians).map(radiansToUnitVector);

uvs.forEach(uv => console.log(uv));
> Object {x: 1, y: 0}
> Object {x: 0.7071067811865476, y: 0.7071067811865475}
> Object {x: 6.123233995736766e-17, y: 1}
					</code></pre>
					<aside class="notes">
						There are several libraries that provide a fuller set of functional
						operators, but the Array object provides a basic set and it's already
						supported in most modern browsers.
					</aside>
				</section>

				<section>
					<h2>Checking Our Work</h2>
					<pre><code data-trim class="javascript">
var unitVectorToLength = ({x, y}) => {
	return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))
};

var averageLength = uvs.reduce((tot, val) => {
  return tot + unitVectorToLength(val);
}, 0) / uvs.length;

console.log(averageLength)
> 1
					</code></pre>
					<aside class="notes">
						Check out the arrow function. Notice the '{x, y}' at the start. That's
						destructuring in action! We're saying take the object that is given and
						pull out the x and y properties as arguments for the function. Nice!
					</aside>
				</section>

				<section>
					<h2>What is 'this'?</h2>
					<pre><code data-trim class="javascript">
// OFTEN SEEN IN THE WILD!!!
'use strict';
function foo() {
	this.value = 42;

	var self = this;

	function bar() {
		console.log(self.value);
	}

	bar();
}
foo();
> 42
					</code></pre>
					<aside class="notes">
						Every function has a 'this' property that is runtime bound.

						It is not:
						<ul>
							<li>a reference to the function</li>
							<li>the function's scope</li>
						</ul>

						<p>NOTE: Without strict mode, 'this' will sometimes be set to the global
							window Object. In that case, using this in the inner function would
							appear to work as expected, but for the wrong reason.</p>
					</aside>
				</section>

				<section>
					<h2>How about 'this'?</h2>
					<pre><code data-trim class="javascript">
// BETTER? Maybe. MORE CORRECT? Definitely.
'use strict';
function foo() {
	this.value = 42;

	function bar() {
		console.log(this.value);
	}

	bar.bind(this)();
	bar.apply(this);
	bar.call(this);
}
foo();
> 42
> 42
> 42
					</code></pre>
					<aside class="notes">
						Every Function has an apply() and call() that allow you to execute a function
						with a predefined 'this'. The only difference is that apply() takes arguments
						as an array like object and call() takes them individually.

						Every Function also has a bind() that allows you to create a copy of the function
						with 'this' already defined. Partials, anybody?
					</aside>
				</section>

				<section>
					<h2>Classes?</h2>
					<p class="fragment">First, do you really need them?</p>
					<p class="fragment">If you do, then ES6 makes it much easier.</p>
					<aside class="notes">
						JavaScript is a prototype based language, so you're never going to have classes
						exactly like you have classes in Java. But, you can get close and you even have some
						choice about how close.

						The easiest approach in ES6 uses the new class syntax.
					</aside>
				</section>

				<section>
					<h2>class (ES6)</h2>
					<pre><code data-trim class="javascript">
class Base {
	constructor(name) {
		this.name = name;
	}
	sayHello() {
		console.log("Hi, my name is " + this.name);
	}
}
					</code></pre>
					<pre class="fragment"><code data-trim class="javascript">
class Extended extends Base {
	constructor(name, surname) {
		super(name);
		this.surname = surname;
	}
	sayHello() {
		console.log("Hi, my name is " + this.name + " " + this.surname);
	}
}
					</code></pre>
					<aside class="notes">
						There can only be one 'constructor' method. There isn't a way to define class
						properties other than it's constructor and methods. This is really just syntactic
						sugar on top of regular Object prototypes.
					</aside>
				</section>

				<section>
					<h2>What We Didn't Cover</h2>
					<ul>
						<li>strict mode</li>
						<li>Prototypes</li>
						<li>Promises</li>
						<li>Symbols (ES6)</li>
						<li>Template Literals (ES6)</li>
						<li>Generators (ES6)</li>
						<li>Modules (ES6)</li>
						<li>Collections (ES6)</li>
					</ul>
					<aside class="notes">
						Besides the new 'class' syntax, there's good old prototype expressions.

						Promises are already supported by a lot of frameworks and libraries, but in
						ES6 they're native!

						Template literals are a better way to compose Strings using variables in the scope.

						Collections including Maps and Sets!
					</aside>
				</section>

				<section>
					<h2>Living In The Future</h2>
					<p><a href="https://kangax.github.io/compat-table/es6/">https://kangax.github.io/compat-table/es6/</a></p>
					<p class="fragment">Language Extensions</p>
					<p class="fragment">Language Additions</p>
					<aside class="notes">
						Let's define extensions as things like new methods on existing builtins.

						Let's define additions as syntax changes or entirely new builtins.
					</aside>
				</section>

				<section>
					<h2>Shims</h2>
					<p>es6-shim</p>
					<p><a href="https://github.com/paulmillr/es6-shim">https://github.com/paulmillr/es6-shim</a></p>
					<p>Mozilla Developer Network (MDN)</p>
					<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></p>
				</section>

				<section>
					<h2>Transpilers</h2>
					<p>Traceur</p>
					<p><a href="https://github.com/google/traceur-compiler">https://github.com/google/traceur-compiler</a></p>
					<p>Babel</p>
					<p><a href="https://babeljs.io/">https://babeljs.io/</a></p>
					<p>ScratchJS</p>
					<p><a href="https://chrome.google.com/webstore/detail/scratch-js/alploljligeomonipppgaahpkenfnfkn?hl=en-US">https://chrome.google.com/webstore/detail/scratch-js/alploljligeomonipppgaahpkenfnfkn?hl=en-US</a></p>
				</section>

				<section>
					<h2>Awesome JavaScript</h2>
					<p>Node.js</p>
					<p><a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
					<p><a href="https://github.com/sindresorhus/awesome-nodejs">https://github.com/sindresorhus/awesome-nodejs</a></p>
					<p>Electron</p>
					<p><a href="https://github.com/atom/electron">https://github.com/atom/electron</a></p>
					<p><a href="https://github.com/sindresorhus/awesome-electron">https://github.com/sindresorhus/awesome-electron</a></p>
				</section>

				<section>
					<h2>Questions?</h2>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
